use std::str::FromStr;
use super::{Sexp};

grammar;

match {
	r"true|false"
}
else {
	_
}

Id: String = <s:r"[a-zA-Z][a-zA-Z0-9]*"> => String::from(s);
Int: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();
Bool: bool = <s:r"true|false"> => bool::from_str(s).unwrap();
Str: String = <s:r##""(\\"|.)*""##> => String::from(&s[1..s.len()-1]);

Sexps: Vec<Sexp> = {
	=> Vec::new(),
	<mut ss:Sexps> <s:Sexp> => { ss.push(s); ss }
}

pub Args: Vec<String> = {
	=> Vec::new(),
	<mut args:Args> <arg:Id> => { args.push(arg); args }
}

pub Sexp: Sexp = {
	<n:Int> => Sexp::Int(n),
	<b:Bool> => Sexp::Bool(b),
	<s:Str> => Sexp::Str(s),
	<var:Id> => Sexp::Var(var),
	"'(" <ss:Sexps> ")" => Sexp::List(ss),
	"(" "if" <cond:Sexp> <expr_then:Sexp> <expr_else:Sexp> ")" => Sexp::If(Box::new(cond), Box::new(expr_then), Box::new(expr_else)),
	"(" "let" <id:Id> <def:Sexp> <expr:Sexp> ")" => Sexp::Let(id, Box::new(def), Box::new(expr)),
	"(" "letrec" <id:Id> <def:Sexp> <expr:Sexp> ")" => Sexp::Let(id, Box::new(def), Box::new(expr)),
	"(" "lambda" "(" <args:Args> ")" <expr:Sexp> ")" => Sexp::Lambda(args, Box::new(expr)),
	"(" <id:Id> <ss:Sexps> ")" => Sexp::Call(id, ss),
}
